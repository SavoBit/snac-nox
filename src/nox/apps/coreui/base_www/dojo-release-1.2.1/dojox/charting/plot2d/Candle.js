dojo.provide("dojox.charting.plot2d.Candle");

dojo.require("dojox.charting.plot2d.common");
dojo.require("dojox.charting.plot2d.Base");

dojo.require("dojox.lang.utils");
dojo.require("dojox.lang.functional");
dojo.require("dojox.lang.functional.reversed");

(function(){
    var df = dojox.lang.functional, dc = dojox.charting.plot2d.common,du = dojox.lang.utils,
	purgeGroup = df.lambda("item.purgeGroup()");
    
    dojo.declare("dojox.charting.plot2d.Candle", dojox.charting.plot2d.Base, {
        defaultParams: {
			hAxis: "x",		// use a horizontal axis named "x"
			vAxis: "y",		// use a vertical axis named "y"
			gap:	5,		// gap between columns in pixels
			shadows: null	// draw shadows
		},
		optionalParams: {},	// no optional parameters
		
		constructor: function(chart, kwArgs){
			this.opt = dojo.clone(this.defaultParams);
			du.updateWithObject(this.opt, kwArgs);
			this.series = [];
			this.hAxis = this.opt.hAxis;
			this.vAxis = this.opt.vAxis;
		}, 
		calculateAxes: function(dim){
			var stats = dc.collectCandleStats(this.series);
			stats.hmin -= 0.5;
			stats.hmax += 0.5;
			this._calc(dim, stats);
			return this;
		},
	
        render: function(dim, offsets){
			this.dirty = this.isDirty();
			if (this.dirty) {
				dojo.forEach(this.series, purgeGroup);
				this.cleanGroup();
				var s = this.group;
				df.forEachRev(this.series, function(item){
					item.cleanGroup(s);
				});
			}
			var t = this.chart.theme, color, stroke, fill, f,
				ht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),
				vt = this._vScaler.scaler.getTransformerFromModel(this._vScaler),
				gap = this.opt.gap < this._hScaler.bounds.scale / 3 ? this.opt.gap : 0,
				thickness = (this._hScaler.bounds.scale - 2 * gap) / this.series.length,
				baseline = Math.max(0, this._vScaler.bounds.lower),
				baselineHeight = vt(baseline),
				xoff = offsets.l + this._hScaler.bounds.scale * (0.5 - this._hScaler.bounds.lower) + gap,
				yoff = dim.height - offsets.b - this._vScaler.bounds.scale * (baseline - this._vScaler.bounds.lower),
				//width  = this._hScaler.bounds.scale - 2 * gap;
				width = thickness;
				
			for (var i = this.series.length - 1; i >= 0; --i) {
				var run = this.series[i],
					shift = thickness*i;

				if(!this.dirty && !run.dirty){ continue; }
				run.cleanGroup();
				var s = run.group;

				if(!run.fill || !run.stroke){
					// need autogenerated color
					color = run.dyn.color = new dojo.Color(t.next("color"));
				}

				stroke = run.stroke ? run.stroke : dc.augmentStroke(t.series.stroke, color);
				fill = run.fill ? run.fill : dc.augmentFill(t.series.fill, color);

				for(var j = 0; j < run.data.length; ++j){

					var reclow 		= run.data[j].lq,
						rechigh 	= run.data[j].uq,
						reclowS 	= vt(reclow),
						rechighS 	= vt(rechigh),
						mid			= vt(run.data[j].md),
						midh		= mid - reclowS,
						h 			= rechighS - reclowS;
						
					var low		= run.data[j].lx,
						lowS	= vt(low),
						high	= run.data[j].ux,
						highS	= vt(high),
						totH	= highS - lowS;
						

						var x1 = offsets.l + ht(j+ 0.5) + gap + shift,
							x2 = x1 + width;
							y1 = dim.height - offsets.b - (rechigh > baseline? rechighS: baselineHeight),
							y2 = y1 + h,
							y3 = y1 + midh,
							x3 = x1 + width/2,
							y4 = dim.height - offsets.b - (low > baseline? lowS: baselineHeight),
							y5 = y4 - totH;
							
							
						shape = s.createShape({type:"path"}).
								setStroke(stroke).
								//draw the box
								moveTo(x1,y1).
								lineTo(x1,y2).
								lineTo(x2,y2).
								lineTo(x2,y1).
								lineTo(x1,y1).
								// draw median horizontal line
								moveTo(x1,y3).
								lineTo(x2,y3).
								// draw Top and bottom vertical lines of candle
								moveTo(x3,y5).
								lineTo(x3,y1).
								moveTo(x3,y2).
								lineTo(x3,y4).
								setTransform({});
						run.dyn.fill   = shape.getFill();
						run.dyn.stroke = shape.getStroke();
				}
				run.dirty = false;
			}
			this.dirty = false;
			return this;
			
		}		
    });
    
    
    
})();
